# kmp算法简单介绍

* # 用途

  在字符串相关的题目当中，我时常遇到如下问题:

  题目中给定了两个字符串S和T，要求我们判断T在S中是否有过出现并且输出T在S当中具体的出现位置，我们可以称字符串S为文本串（也叫主串），称T为模式串

  在不考虑时间复杂度的情况之下，这是一个非常简单的问题，我们可以直接采取朴素字符串匹配方法

  原理：从主串的指定的起始位置字符开始和模式第一个字符比较，如果相等，则继续比较下一个字符，如果不等，则从主串的下一个字符开始和模式的第一个字符开始比较，以此类推，直到模式串所有字符都匹配完成，则匹配成功，否则，匹配不成功。

  正如其名称一般，代码也相当朴素

  ```c++
  int index_force(char * s, char * t,int pos)
  {
      int i=pos-1;
      //判断pos是否合法
      if(!s[i])
      cout<<"起始位置不合法"<<endl;
      int j=0;
      while(s[i]!='\0' && t[j]!='\0')//主串或者模式串遍历完成
      {
          if(s[i]==t[j])//如果主串和模式串对应位置的值相等，则比较后面的字符
          {
              ++i;
              ++j;
          }
          else    //如果不相等，则模式串需要回朔到第一个字符，而主串则从下一个字符开始
          {
              i=i-j+1;
              j=0;
          }
      }
      if(t[j]=='\0')//如果循环是由于模式串遍历完了而结束的，说明找到了对应子串的位置
      {
          return i-j+1;
      }
      else        //否则，主串不包含模式串
      {
          return 0;
      }
  }
  ```
  由于从原理到实现都比较简单，因此在这里就不细讲了

  不过这个算法有一个非常致命的缺陷就是时间复杂度，由于我们是逐个匹配的，对于长度为m的主串和长度为n的模式串， 其串的匹配次数为m-n+1次，而每一次匹配都需要检索模式串中的n个字符，那么一共就需要进行(m-n+1)*n次，当我们设定m-n+1和n在同一个数量级的时候，该算法的时间复杂度接近于
  $$
  O(n^2)
  $$
  好像可以接受，但不完全能接受
  
  当n的范围较大的时候，显然这种做法就应该被pass掉了
  
  为了针对这种一对一字符串匹配问题进行改进，我们引入了KMP算法来提升效率
  
  **KMP算法是一种较为高效的，用于解决单模式串匹配单主串问题的算法**
  
  ---
  
  # 基本思想/原理
  
  
  
  我们可以发现，在朴素字符串匹配方法当中，其低效主要源自于一些无用的重复匹配，当我们用肉眼观察的时候，就可以发现，当我们有一个模式串ABCABCD的时候，前后有不同位置的两个A AB ABC这三种子串，如果在某一个匹配当中后面的位置是匹配上的，那么我们就不需要进行逐个的移动匹配的头指针，而可以直接把模式串前面的部分移动至后面已经匹配过的位置，这样可以极大地增大匹配的效率，而这也是KMP算法的根本原理:**通过对模式串的一个预处理，大量减少了无用的指针移动，从而减少匹配次数，最终将我们的时间复杂度减少到了一个线性的水平**
  
  比如说在如下的图当中
  
  ![这里写图片描述](C:\Users\Ahpasia\Desktop\se知识点\SouthEast)
  
  现在模式串的第六个字符和主串匹配不上了，那么现在我们就需要把模式串往右移动，并且重新选择主串和模式串的比较位置重新开始比较。那么如果是朴素法的话，我们是直接把模式串往右移动一格，然后，主串的第四个字符和我们模式串的第一个字符重新开始做比较。但是，你要知道其实主串的第三个字符到第六个字符我们都是已经和模式串做过比较的，而且我们知道他们的各个位置上的内容是什么，那么为什么不把这些已经知道的信息充分利用起来了？比如：我们知道模式串中红色的两个字符和绿色的两个字符是相等的，而且红色的两个字符正好是模式串开始的两个字符，所以我们可以直接把模式串向右移动四位，然后，我们主串从刚才发现不匹配那个字符位置开始和模式串的第三个位置比较，这样我们就可以减少五次比较。
  
  将这种做法进行代码的实现，就是KMP算法。
  
  # 实现方法
  
  
  
  为了实现KMP算法，我们需要引入next数组这个概念
  
  通过预处理我们可得到next数组，next数组的含义就是一个固定字符串的最长前缀和最长后缀相同的长度。
  
  如果上述说法有些难懂的话，可以将其理解为，它保存的东西就是当我们在模式串某个位置匹配失败后，应该从模式串的哪个位置重新开始比较。
  
  比如：abcjkdabc，那么这个数组的最长前缀和最长后缀相同必然是abc。
  cbcbc，最长前缀和最长后缀相同是cbc。
  abcbc，最长前缀和最长后缀相同是不存在的。
  
  **注意最长前缀：是说以第一个字符开始，但是不包含最后一个字符。
  比如aaaa相同的最长前缀和最长后缀是aaa。**
  对于目标字符串ptr，ababaca，长度是7，所以next[0]，next[1]，next[2]，next[3]，next[4]，next[5]，next[6]分别计算的是
  a，ab，aba，abab，ababa，ababac，ababaca的相同的最长前缀和最长后缀的长度。由于a，ab，aba，abab，ababa，ababac，ababaca的相同的最长前缀和最长后缀是“”，“”，“a”，“ab”，“aba”，“”，“a”,所以next数组的值是[-1,-1,0,1,2,-1,0]，这里-1表示不存在，0表示存在长度为1，2表示存在长度为3。这是为了和代码相对应。
  
  以**基本思想/原理**中的例子作为标准，要求得next数组，我们就要理解在为什么可以从模式串的第三个位置重新开始比较。其实next数组就是说对于模式串j这个位置之前（1到j-1）的串中，是否存在从模式串第一个位置出发往右移动得到的子串和从模式串的第j-1个字符位置出发往左移动得到的子串匹配，而且当该串达到最大长度时，则next值就是该串的长度加一，例如：abaabc这个模式串中，在c这个位置之前存在一个最大子串：ab。然后，我们next值就是记录这个最大子串的下一个字符的位置，其实说到这里，我们也就理解到了为什么要第三个字符了，因为模式串的前两个字符已经和主串匹配成功了（生成next值的时候，就完成了这个任务），所以不用再比较了。
  
  求得next数组的代码非常简单，但是其思想是较难理解的，需要对于代码进行反复阅读和深入体会
  
  ```c++
  void cal_next(char *str, int *next, int len)
  {
      next[0] = -1;//next[0]初始化为-1，-1表示不存在相同的最大前缀和最大后缀
      int k = -1;//k初始化为-1
      for (int q = 1; q <= len-1; q++)
      {
          while (k > -1 && str[k + 1] != str[q])//如果下一个不同，那么k就变成next[k]，注意next[k]是小于k的，无论k取任何值。
          {
              k = next[k];//往前回溯
          }
          if (str[k + 1] == str[q])//如果相同，k++
          {
              k = k + 1;
          }
          next[q] = k;//这个是把算的k的值（就是相同的最大前缀和最大后缀长）赋给next[q]
      }
  }
  ```
  
  KMP的过程，本质上就是在主串上不断地跑next数组的过程，代码如下
  
  ```C++
  int KMP(char *str, int slen, char *ptr, int plen)
  {
      int *next = new int[plen];
      cal_next(ptr, next, plen);//计算next数组
      int k = -1;
      for (int i = 0; i < slen; i++)
      {
          while (k >-1&& ptr[k + 1] != str[i])//ptr和str不匹配，且k>-1（表示ptr和str有部分匹配）
              k = next[k];//往前回溯
          if (ptr[k + 1] == str[i])
              k = k + 1;
          if (k == plen-1)//说明k移动到ptr的最末端
          {
              //cout << "在位置" << i-plen+1<< endl;
              //k = -1;//重新初始化，寻找下一个
              //i = i - plen + 1;//i定位到该位置，外层for循环i++可以继续找下一个（这里默认存在两个匹配字符串可以部分重叠），感谢评论中同学指出错误。
              return i-plen+1;//返回相应的位置
          }
      }
      return -1;  
  }
  ```
  
  我们可以看到，匹配串每次往前移动，都是一大段一大段移动，假设匹配串里不存在重复的前缀和后缀，即next的值都是-1，那么每次移动其实就是一整个匹配串往前移动m个距离。然后重新一一比较，这样就比较m次，概括为，移动m距离，比较m次，移到末尾，就是比较n次，O(n)复杂度。 假设匹配串里存在重复的前缀和后缀，我们移动的距离相对小了点，但是比较的次数也小了，整体代价也是O(n)。
  所以复杂度就成了线性。
  
  当然，next数组可以有更深的理解，可以去参考一下NOI2014的动物园，不过在本篇中主要涉及KMP相关的知识点，因此不多赘述。